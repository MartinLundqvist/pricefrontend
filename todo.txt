1. Refactor the BasketContextProvider so that the Store utils are managed separately. Perhaps a class?
1b. Also, the algorithms aren't fully battle tested...
2. Build-out the search results to proper cards - pick a design for that
3. Move the Basket into a separate place. 
4. Create a decent design for th pages
5. Fix the issue with Pricerunner returning a different page when non-categorized results are returned
6. Add schema validation on the API responses - probably put these in the Common workspace.
7. Allow user to pick how many matching offers to return
8. Remove the Alert() thingies from the front-end. 
9. Get the thing ready for deployment...



=> Need a unique product. So user has to select. 
=> Show a the full set of products that matched.
=> Ask user to mark the offers she wants to retain.
=> The IResponse.IVendorSearchResult array is then filtered to only retain the ones the user selects.

=> The ones the user wants to retain are store in two places:

A new StoreProduct entry with an array of all offers that the user has chosen to keep. Technically this just means adding the ISearchResults.IVendorSearchresults to the IStore.vendors array.
export interface IStoreProduct {
  product: string;
  vendors: /*IVendorSearchResult*/ {
    vendor: string;
    productOfferID: string; // Generated by the back-end!
    productOffer: string;
    priceOffer: number;
  }[];
}

And a push (or creation) of a new IStoreVendor entry where the associated product and vendor offer is pushed into the product array.
export interface IStoreVendor {
  vendor: string;
  products: {
    product: string;
    productOfferID: string; // Generated by the back-end!
    productOffer: string;
    priceOffer: number;
  }[];
  totalPriceOffer: number;
}


=> Group results by vendor. Do that on the back-end. 